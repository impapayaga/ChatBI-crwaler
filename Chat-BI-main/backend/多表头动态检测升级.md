# 多表头动态检测升级

## ✅ 升级完成

已将表头检测从**固定3级**升级为**支持任意层级**的动态检测。

## 🔄 升级对比

### 升级前（限制3级）
- `max_rows=3`：固定最多检测3行
- 无法处理超过3级的表头

### 升级后（支持任意层级）
- `max_rows=10`：默认最多检测10行（可配置）
- **动态检测**：直到遇到明显的数据行为止
- 支持1-10级表头（理论上可扩展到更多）

## 🎯 核心改进

### 1. 动态检测策略

**之前**：固定检查前3行
```python
for i in range(1, min(max_rows, len(preview_df))):  # max_rows=3
    # 检查条件...
```

**现在**：动态检测直到遇到数据行
```python
for i in range(1, min(max_rows, len(preview_df))):  # max_rows=10
    # 检查条件...
    if numeric_ratio > 0.7:  # 如果数值比例>70%，认为是数据行
        break  # 停止检测
```

### 2. 增强的检测条件

#### 新增特征
1. **数据类型分析**：
   - `string_ratio`：字符串比例
   - `numeric_ratio`：数值比例
   - 表头通常是字符串，数据行通常有数值

2. **行间对比**：
   - 与前一行对比，如果结构相似（都有空值），可能是同一层级表头

3. **数据置信度**：
   - `min_data_confidence=0.7`：如果数值比例>70%，几乎肯定是数据行
   - 自动停止检测，避免误判

### 3. 检测逻辑

```python
判断是否为表头行：
├─ 条件1：空值比例 > 30% → 可能是合并单元格 → 是表头
├─ 条件2：唯一值比例 < 50% → 可能是重复表头 → 是表头
├─ 条件3：字符串比例 > 80% 且 数值比例 < 20% → 是表头
├─ 条件4：与前一行都有空值（>20%） → 可能是多层级表头 → 是表头
└─ 否则：
    └─ 如果数值比例 > 70% → 肯定是数据行 → 停止检测
```

## 📊 使用示例

### 示例1：4级表头
```
原始Excel:
| 年度 | 2023年（合并） | 2024年（合并） | 其他 |
|      | Q1-Q2（合并） | Q3-Q4（合并） | Q1-Q2（合并） | Q3-Q4（合并） |      |
|      | Q1  | Q2  | Q3  | Q4  | Q1  | Q2  | Q3  | Q4  |      |
|      | 销售额 | 利润 | 销售额 | 利润 | ... | ... | ... | ... |      |
| 数据 | 100 | 10  | 200 | 20  | ... | ... | ... | ... | ...  |
```

**检测结果**：
- 检测到4行表头：`[0, 1, 2, 3]`
- 列名合并为：`年度`, `2023年_Q1-Q2_Q1_销售额`, `2023年_Q1-Q2_Q1_利润`, ...

### 示例2：2级表头（原有功能）
```
原始Excel:
| 姓名 | 成绩（合并） | 其他 |
|      | 语文 | 数学 | 英语 |      |
```

**检测结果**：
- 检测到2行表头：`[0, 1]`
- 列名合并为：`姓名`, `成绩_语文`, `成绩_数学`, `成绩_英语`, `其他`

### 示例3：单级表头（向后兼容）
```
原始Excel:
| 姓名 | 语文 | 数学 | 英语 | 其他 |
```

**检测结果**：
- 检测到1行表头：`[0]`
- 列名：`姓名`, `语文`, `数学`, `英语`, `其他`

## 🔧 配置参数

### `max_rows`（最大检测行数）
- **默认值**：10
- **作用**：防止无限循环，限制最大检测行数
- **调整**：如果遇到超过10级的表头，可以增加此值

```python
# 在调用时自定义
header_rows = detect_header_rows(file_data, engine='openpyxl', max_rows=15)
```

### `min_data_confidence`（数据置信度阈值）
- **默认值**：0.7（70%）
- **作用**：如果一行中数值比例>70%，认为是数据行，停止检测
- **调整**：如果表头中有很多数值（如"2024年"、"Q1"），可以降低此值

```python
# 在调用时自定义
header_rows = detect_header_rows(
    file_data, 
    engine='openpyxl', 
    max_rows=10,
    min_data_confidence=0.5  # 降低阈值，更宽松
)
```

## 📝 日志输出

### 检测到多级表头
```
INFO: 检测到 4 行表头: [0, 1, 2, 3]
INFO: 使用多行表头读取: header=[0, 1, 2, 3]
INFO: 多表头合并完成，列名示例: ['年度', '2023年_Q1-Q2_Q1_销售额', ...]
```

### 检测到数据行，停止检测
```
INFO: 在第 5 行检测到数据特征（数值比例: 0.85），停止检测
INFO: 检测到 4 行表头: [0, 1, 2, 3]
```

### 降级情况
```
WARNING: 表头行数检测失败，使用单行表头: ...
```

## ⚠️ 注意事项

1. **性能影响**：
   - 检测范围从3行增加到10行（可配置）
   - 但检测逻辑更智能，通常会在遇到数据行时提前停止
   - 实际性能影响很小

2. **边界情况**：
   - 如果表头中包含大量数值（如"2024年"、"Q1"），可能被误判为数据
   - 可以通过降低 `min_data_confidence` 阈值解决

3. **向后兼容**：
   - ✅ 单行表头文件：正常工作
   - ✅ 2-3行表头文件：正常工作
   - ✅ 4-10行表头文件：现在也支持了

## 🎉 总结

✅ **已升级**：从固定3级升级为支持任意层级（最多10级，可配置）
✅ **更智能**：动态检测，遇到数据行自动停止
✅ **向后兼容**：单级、多级表头都正常工作
✅ **可配置**：`max_rows` 和 `min_data_confidence` 可调整

现在系统可以处理任意层级的表头结构了！🚀


